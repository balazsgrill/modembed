grammar hu.e.parser.ESyntax with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate eSyntax "http://www.e.hu/parser/ESyntax"

CompilationUnit:
	Library | InstructionSetNotation | WorkflowNotation
;	

LibraryName:
	ID ('.' ID)*
;

QualifiedName:
	(LibraryName '::')? ID
;

//ReferenceID:
//	ID ('->' ID)*
//;

/***********************
 * LITERALS *
 ***********************/

terminal HEXINT returns ecore::EInt: '0x'('0'..'9'|'a'..'f'|'A'..'F')+;

terminal BINARY returns ecore::EInt: 'b'('0'|'1')+;

terminal REAL returns ecore::EBigDecimal: INT '.' INT?;

//terminal CHAR returns ecore::EString: 'a'..'z'|'A'..'Z';

LITERAL: (INT | HEXINT | BINARY | REAL);

/**********************
 * Annotations
 ***********************/

AnnotationDefinition:
	'annotation' name=ID
;

Annotation:
	'#' definition=ID
;

/**********************
 * Workflow notation
 **********************/

WorkflowNotation:
	'workflow' name=LibraryName ';'
	(steps += WorkflowStepNotation)*
;

WorkflowStepNotation:
	type=LibraryName '{'
		(params += WorkflowStepParameterNotation)*
	'}'
;

WorkflowStepParameterNotation:
	parameter=ID '=' (value=STRING | value=LibraryName)
;

/**********************
 * InstructionSet
 **********************/

InstructionSetNotation:
	'instructionset' name=LibraryName
	('extends' extends=LibraryName)? ';'
	
	(instructions += InstructionNotation)*
;

InstructionNotation:
	name=ID  (params+=InstructionParameterNotation)* (words+=InstructionWordNotation)+
;

InstructionWordNotation:
	'<' (sections+=InsctructionSectionNotation)+ '>'
;

InstructionParameterNotation:
	name=ID ('=' default=LITERAL)? 
;

InsctructionSectionNotation:
	(('$'param=ID) | (value=LITERAL)) ':' size=LITERAL (':' shift=LITERAL)?
;

/***********************
 * LIBRARY *
 ***********************/

Library:
	'library' name=LibraryName
	//('overrides' overrides+=[Library|QualifiedName] (',' overrides+=[Library|QualifiedName])*)?
	';'
	('use' use+=LibraryName';')*
	(items+=LibraryItem)*
;

LibraryItem:
	Type | Operation | Variable';' | 
	ConstantVariable';' | RegisterVariable';' 
	| AnnotationDefinition ';'
	;

/***********************
 * DATATYPES *
 ***********************/	
Type:
	'type' name=ID '=' def=TypeDef ';';

TypeDef:
	DataTypeDef | StructTypeDef | PointerTypeDef | ArrayTypeDef | RefTypeDef | UnspecifiedTypeDef
;
	
UnspecifiedTypeDef :
	{UnspecifiedTypeDef} 'void'
;	
	
PointerTypeDef:
	 'pointer' '<'def=TypeDef'>'
;	
	
ArrayTypeDef:
	'array' '<' def=TypeDef '>' ('[' size=XExpression ']')?
;

RefTypeDef:
	type=QualifiedName
;	
	
DataTypeDef:
	IntegerDataTypeDef | FixedDataTypeDef | LabelDataTypeDef //| FloatDataTypeDef
	;

LabelDataTypeDef:
	{LabelDataTypeDef} 'label'
;

//FloatDataTypeDef:
//	'float' bits=INT 'bits'
//;

FixedDataTypeDef:
	'fixed' bits=INT 'bits' 'scale' '=' scale=REAL
;

IntegerDataTypeDef:
	kind=IntegerKind bits=INT 'bits'
;

enum IntegerKind:
	UNSIGNED='unsigned' | SIGNED='signed'
;
	
StructTypeDef:
	{StructTypeDef} 'struct' '{'
		(members += StructTypeDefMember)
		(',' members += StructTypeDefMember)*
	'}';

StructTypeDefMember returns Variable:
	{StructTypeDefMember} type=TypeDef name=ID
;

/*************************
 * GLOBAL VARIABLES
 *************************/

ConstantVariable returns Variable: 
	{ConstantVariable} 'const' type=TypeDef name=ID '=' value=XExpression
;

RegisterVariable returns Variable:
	{RegisterVariable} 'reg' type=TypeDef name=ID ':' addr=XExpression
;

/***********************
 * Operation *
 ***********************/

OperationStep:
	(Variable';') | XTopLevelExpression
;

Variable:
	type=TypeDef name=ID
;

VariableReference:
	var=QualifiedName
;

OperationCall:
	operation=QualifiedName '('
		(params+=OperationCallParameter (',' params+=OperationCallParameter)*)?
	')'
;

OperationCallParameter:
	XExpression
;

OperationTypeDef:
	resultType=TypeDef '('
		(params+=OperationParameter (',' params+=OperationParameter)*)? 
	 ')'
;

Operation:
	'function' name=ID type=OperationTypeDef ('overrides' overrides=QualifiedName)? 
	content = XExpression 
;

OperationParameter:
	ParameterVariable | LazyParameter
;

LazyParameter:
	'lazy' paramname=ID type=OperationTypeDef
;

ParameterVariable returns Variable:
	{ParameterVariable} (kind=ParameterKind)? type=TypeDef name=ID ('=' default=LITERAL)?  
;

enum ParameterKind:
	ANY='default' | VAR='var' | CONST='const'
;

/********************
 * INFIX SYNTAX
 **********************/
 
XExpression:
	XExpression6 (':' type=TypeDef)?;

XExpressionBlock:
	'{' {OperationBlock} (steps+=OperationStep)*  ('return' result=XExpression)? '}'
;

XPrimaryExpression:
	XExpressionLiteral | XParenthesizedExpression | XIsLiteralExpression | VariableReference | OperationCall
	 | XStructExpression | XSizeOfExpression | XExpressionBlock
;

XSizeOfExpression:
	'sizeof' '(' type = TypeDef ')'
;

XStructExpression:
	'[' values+=XExpression (',' values+=XExpression)* (',')? ']'
;

XExpression1:
	(operator += UNARY_OPERATOR)* a=XExpression0
;

XExpression0:
	a=XExpressionM1 ('->' member+=ID)*
;

XExpressionM1:
	a=XPrimaryExpression ('[' index+=XExpression ']')*
;

enum UNARY_OPERATOR:
	MINUS='-' | NOT='!' | REFERENCE='&' | DEREFERENCE='@'
;

XExpression2:
	a = XExpression1 (=> op+=MULTIPLICATIVE_OPERATOR b+= XExpression2)*
;

enum MULTIPLICATIVE_OPERATOR:
	MUL='*' | DIV='/' | MOD='%'
;

XExpression3:
	a = XExpression2 (=> op+=ADDITIVE_OPERATOR b+= XExpression2)*
;

enum ADDITIVE_OPERATOR:
	ADD='+' | 
	MINUS='-'
;

XExpression4:
	a = XExpression3 (=> op+=EQUALITY_OPERATOR b+=XExpression3)*
;

enum EQUALITY_OPERATOR:
	EQUALS='==' | NOTEQUALS='!=' | GTE='>=' | LTE='<=' | GT='>' | LT='<'
;

XExpression5:
	a = XExpression4 (=> op+=BOOLEAN_OPERATOR b+=XExpression4)*
;

XExpression6:
	(ref=VariableReference op=OpSingleAssign)? a=XExpression5
;

enum BOOLEAN_OPERATOR:
	OR='||' | AND='&&' 
;

XExpressionLiteral:
	value=LITERAL
;

XTopLevelExpression:
	Annotation ';' | XExpression ';' | XErrorExpression ';' 
;

XErrorExpression:
	level=ErrorLevels msg=STRING ';'
;

enum ErrorLevels:
	ERROR = 'error' | WARNING = 'warning' | INFO = 'info'
;

enum OpSingleAssign:
	ASSIGN = '=' | ASSIGNADD= '+=' | ASSIGNSUBTRACT = '-='
;

XIsLiteralExpression:
	'isliteral' '('
		ref = VariableReference
	')'
;

XParenthesizedExpression:
	'(' a=XExpression ')';

	