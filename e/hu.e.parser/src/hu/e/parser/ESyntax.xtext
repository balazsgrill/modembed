grammar hu.e.parser.ESyntax with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate eSyntax "http://www.e.hu/parser/ESyntax"

CompilationUnit:
	/*Module |*/ Library | LinkedBinary /*| Interface*/
;	

QualifiedName:
	ID ('.' ID)*
;

//ReferenceID:
//	ID ('->' ID)*
//;

/***********************
 * LITERALS *
 ***********************/

terminal HEXINT returns ecore::EInt: '0x'('0'..'9'|'a'..'f'|'A'..'F')+;

terminal BINARY returns ecore::EInt: 'b'('0'|'1')+;

terminal REAL returns ecore::EBigDecimal: INT '.' INT?;

LITERAL: (INT | HEXINT | BINARY | REAL);

/**********************
 * Annotations
 ***********************/

AnnotationDefinition:
	'annotation' name=ID
;

Annotation:
	'#' definition=[AnnotationDefinition|ID]
;

/***********************
 * LIBRARY *
 ***********************/

Library:
	'library' name=QualifiedName
	('overrides' overrides+=[Library|QualifiedName] (',' overrides+=[Library|QualifiedName])*)?
	';'
	('use' use+=[Library|QualifiedName]';')*
	(items+=LibraryItem)*
;

LibraryItem:
	Type | Operation | Variable';' | 
	ConstantVariable';' | RegisterVariable';' 
	| OperatorDefinition | AnnotationDefinition ';'
	;

/***********************
 * DATATYPES *
 ***********************/	
Type:
	'type' name=ID '=' def=TypeDef ';';

TypeDef:
	DataTypeDef | StructTypeDef | PointerTypeDef | ArrayTypeDef | RefTypeDef
;
	
PointerTypeDef:
	'pointer' 'of' def=TypeDef
;	
	
ArrayTypeDef:
	'array' '[' size=XExpression ']' 'of' def=TypeDef
;

RefTypeDef:
	type=[Type|QualifiedName]
;	
	
DataTypeDef:
	IntegerDataTypeDef | FixedDataTypeDef //| FloatDataTypeDef
	;

//FloatDataTypeDef:
//	'float' bits=INT 'bits'
//;

FixedDataTypeDef:
	'fixed' bits=INT 'bits' 'scale' '=' scale=REAL
;

IntegerDataTypeDef:
	kind=IntegerKind bits=INT 'bits'
;

enum IntegerKind:
	UNSIGNED='unsigned' | SIGNED='signed'
;
	
StructTypeDef:
	{StructTypeDef} 'struct' '{'
		(members += StructTypeDefMember)
		(',' members += StructTypeDefMember)*
	'}';

StructTypeDefMember returns Variable:
	{StructTypeDefMember} type=TypeDef name=ID
;

/*************************
 * GLOBAL VARIABLES
 *************************/

ConstantVariable returns Variable: 
	{ConstantVariable} 'const' type=TypeDef name=ID '=' value=XExpression
;

RegisterVariable returns Variable:
	{RegisterVariable} 'reg' type=TypeDef name=ID ':' addr=XExpression
;

/***********************
 * Operation *
 ***********************/

OperationStep:
	InstructionWord | Label | (Variable';') | XTopLevelExpression
;

Label returns Variable:
	{Label} 'label' name=ID ';'
;

InstructionWord:
	'<' (sections+=WordSection)+ '>'
;

WordSection:
	(LiteralValue | VariableReference ) ':' size=INT (':' shift=INT)? ;

LiteralValue:
	value=LITERAL;

Variable:
	type=TypeDef name=ID
;

VariableReference:
	var=[Variable|QualifiedName]
;

OperationCall:
	operation=[Operation|QualifiedName] '('
		(params+=OperationCallParameter (',' params+=OperationCallParameter)*)?
	')'
;

OperationCallParameter:
	XExpression
;

OperationSignature returns Variable:
	{OperationSignature} name=ID '('
		(params+=ParameterVariable (',' params+=ParameterVariable)*)?
	')'
; 

Operation returns OperationSignature:
	{Operation} name=ID '('
		(params+=ParameterVariable (',' params+=ParameterVariable)*)?
	')''{'
		block=OperationBlock
	'}' ('returns' (return=XExpression | returnvar=Variable) ';')?
;

OperationBlock:
	{OperationBlock} (steps+=OperationStep)*
;

ParameterVariable returns Variable:
	{ParameterVariable} (kind=ParameterKind)? type=TypeDef name=ID ('=' default=LITERAL)?  
;

enum ParameterKind:
	ANY='default' | VAR='var' | CONST='const'
;

/****************
 * OPERATORS
 ******************/

enum OperationRole:
	SET='SET' | ADD='ADD' | SUBTRACT='SUBTRACT' | AND='AND' | OR='OR' | XOR='XOR' |
	EQUALS='EQUALS' | BRANCH='BRANCH' | UC_GOTO='UC_GOTO' | NOT='NOT' | INDIRECTION='INDIRECTION' |
	CLEAR='CLEAR' | INCREMENT='INCREMENT' | DECREMENT='DECREMENT' | DIV='DIV' | MUL='MUL' | MOD='MOD'
	| LT='LT' | LTE='LTE' | GT='GT' | GTE='GTE' | NOTEQUALS='NOTEQUALS'
;

OperatorDefinition:
	'operator' role=OperationRole '{'
		candidate+=[Operation|QualifiedName] (',' candidate+=[Operation|QualifiedName])* (',')?
	'}'
;

/********************
 * BINARY and LINKING
 ********************/

LinkedBinary:
	'binary' name=QualifiedName (type=BinaryType)? ';'
	('use' use+=[Library|QualifiedName]';')*
		(sections+=BinarySection)*
;

enum BinaryType:
	DEFAULT='default' | INTELHEXFILE='intelHexfile' | SRECHEXFILE='SRECHexfile'
;

BinarySection:
	(FunctionBinarySection | ConstantBinarySection | ReferenceBinarySection) 
	'at' start=XExpression  'width' width=LITERAL ';'
;
 
FunctionBinarySection:
	'program' name=ID '('
		'startAddr' '=' startAddr=LITERAL ';'
		'memwidth' '=' memwidth=LITERAL ';'
		'pointerType' '=' pointerType=TypeDef ';'
		'addressType' '=' addressType=TypeDef ';'
		(mems+=FunctionMemory ';')+
		(optimizercalls+=OptimizerCall ';')*
	')' '{'
		(
		('lib' lib+=[Library|QualifiedName] ';') 
		//| (instances+=LinkedInstance )
		)*
		
		'link' '{' do=OperationBlock '}'
	'}'
; 

OptimizerCall:
	'optimize' optimizer=STRING
;

FunctionMemory:
	'mem' start=LITERAL '..' end=LITERAL
;
 
ConstantBinarySection:
	'data' '{' (data+=XExpression ';')+ '}'
; 

ReferenceBinarySection:
	'include' inc=[LinkedBinary|QualifiedName]
;

/********************
 * INFIX SYNTAX
 **********************/
 
XExpression:
	XExpression6 (':' type=TypeDef)?;

XPrimaryExpression:
	XExpressionLiteral | XParenthesizedExpression | XIsLiteralExpression | VariableReference | OperationCall
	 | XStructExpression | XSizeOfExpression
;

XSizeOfExpression:
	'sizeof' '(' type = TypeDef ')'
;

XStructExpression:
	type=[Type|QualifiedName] '{' values+=XExpression (',' values+=XExpression)* (',')? '}'
;

XExpression1:
	(operator += UNARY_OPERATOR)* a=XExpression0
;

XExpression0:
	a=XExpressionM1 ('->' member+=ID)*
;

XExpressionM1:
	a=XPrimaryExpression ('[' index+=XExpression ']')*
;

enum UNARY_OPERATOR:
	MINUS='-' | NOT='!' | REFERENCE='&' | DEREFERENCE='@'
;

XExpression2:
	a = XExpression1 (=> op+=MULTIPLICATIVE_OPERATOR b+= XExpression2)*
;

enum MULTIPLICATIVE_OPERATOR:
	MUL='*' | DIV='/' | MOD='%'
;

XExpression3:
	a = XExpression2 (=> op+=ADDITIVE_OPERATOR b+= XExpression2)*
;

enum ADDITIVE_OPERATOR:
	ADD='+' | 
	MINUS='-'
;

XExpression4:
	a = XExpression3 (=> op+=EQUALITY_OPERATOR b+=XExpression3)*
;

enum EQUALITY_OPERATOR:
	EQUALS='==' | NOTEQUALS='!=' | GTE='>=' | LTE='<=' | GT='>' | LT='<'
;

XExpression5:
	a = XExpression4 (=> op+=BOOLEAN_OPERATOR b+=XExpression4)*
;

XExpression6:
	(ref=VariableReference op=OpSingleAssign)? a=XExpression5
;

enum BOOLEAN_OPERATOR:
	OR='||' | AND='&&' 
;

XExpressionLiteral:
	value=LITERAL
;

XTopLevelExpression:
	Annotation ';' | XExpression ';' | XIfExpression | XWhileExpression | XErrorExpression | XForExpression
;

XErrorExpression:
	level=ErrorLevels msg=STRING ';'
;

enum ErrorLevels:
	ERROR = 'error' | WARNING = 'warning' | INFO = 'info'
;

enum OpSingleAssign:
	ASSIGN = '=' | ASSIGNADD= '+=' | ASSIGNSUBTRACT = '-='
;

XIsLiteralExpression:
	'isliteral' '('
		ref = VariableReference
	')'
;

XIfExpression:
	'if' '(' if=XExpression ')' '{'
	then=OperationBlock
	'}'
	(=> 'else' '{' else=OperationBlock '}')?;
	
XWhileExpression:
	'while' '(' cond=XExpression ')' '{'
		do=OperationBlock
	'}'
;	
	
XForExpression:
	'for' '(' var=Variable from=XExpression ';' by=XExpression ';' to=XExpression ')' '{'
		do=OperationBlock
	'}'
;

XParenthesizedExpression:
	'(' a=XExpression ')';

	