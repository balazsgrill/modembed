grammar hu.e.parser.ESyntax with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate eSyntax "http://www.e.hu/parser/ESyntax"

CompilationUnit:
	Module | Library | LinkedBinary
;	

QualifiedName:
	ID ('.' ID)*
;

ReferenceID:
	(ID '.')? ID
;

/***********************
 * LITERALS *
 ***********************/

terminal HEXINT returns ecore::EInt: '0x'('0'..'9'|'a'..'f'|'A'..'F')+;

terminal BINARY returns ecore::EInt: 'b'('0'|'1')+;

LITERAL: INT | HEXINT | BINARY;

/**********************
 * Annotations
 ***********************/

AnnotationDefinition:
	'annotation' name=ID
;

Annotation:
	'#' definition=[AnnotationDefinition|ID]
;

/***********************
 * CLASSES *
 ***********************/

Module:
	'module' name=QualifiedName
	('extends' extends+=[Module|QualifiedName] (',' extends+=[Module|QualifiedName])*)?
	';'
	('use' use+=[Library|QualifiedName]';')*
	(items+=ModuleItem)*
;

ModuleItem:
	Variable';' | 
	ConfigVariable';' |
	ConstantVariable';' |
	InstanceReference';' |
	Operation
;

InstanceReference:
	'ref' type=[Module|ReferenceID] name=ID
;

ConfigVariable returns Variable:
	{ConfigVariable} 'config' type=TypeDef name=ID
;

/***********************
 * LIBRARY *
 ***********************/

Library:
	'library' name=QualifiedName
	('overrides' overrides+=[Library|QualifiedName] (',' overrides+=[Library|QualifiedName])*)?
	';'
	('use' use+=[Library|QualifiedName]';')*
	(items+=LibraryItem)*
;

LibraryItem:
	Type | Operation | Variable';' | 
	ConstantVariable';' | RegisterVariable';' 
	| OperatorDefinition | AnnotationDefinition ';'
	;

/***********************
 * DATATYPES *
 ***********************/	
Type:
	'type' name=ID '=' def=TypeDef ';';

TypeDef:
	DataTypeDef | StructTypeDef | PointerTypeDef | ArrayTypeDef | RefTypeDef
;
	
PointerTypeDef:
	'pointer' 'of' def=TypeDef
;	
	
ArrayTypeDef:
	'array' '[' size=XExpression ']' 'of' def=TypeDef
;

RefTypeDef:
	type=[Type|ReferenceID]
;	
	
DataTypeDef:
	kind=PrimitiveKind bits=INT 'bits' 
	;

enum PrimitiveKind:
	UNSIGNED='unsigned' | SIGNED='signed' | REAL='real'
;
	
StructTypeDef:
	{StructTypeDef} 'struct' '{'
		(members += StructTypeDefMember)
		(',' members += StructTypeDefMember)*
	'}';

StructTypeDefMember returns Variable:
	{StructTypeDefMember} type=TypeDef name=ID
;

/*************************
 * GLOBAL VARIABLES
 *************************/

ConstantVariable returns Variable: 
	{ConstantVariable} 'const' type=TypeDef name=ID '=' value=XExpression
;

RegisterVariable returns Variable:
	{RegisterVariable} 'reg' type=TypeDef name=ID ':' addr=XExpression
;

/***********************
 * Operation *
 ***********************/

OperationStep:
	InstructionWord | Label | (Variable';') | XTopLevelExpression
;

Label returns Variable:
	{Label} 'label' name=ID ';'
;

InstructionWord:
	'<' (sections+=WordSection)+ '>'
;

WordSection:
	(LiteralValue | VariableReference ) ':' size=INT (':' shift=INT)? ;

LiteralValue:
	value=LITERAL;

Variable:
	type=TypeDef name=ID
;

VariableReference:
	var=[Variable|ReferenceID]
;

OperationCall:
	operation=[Operation|ReferenceID] '('
		(params+=OperationCallParameter (',' params+=OperationCallParameter)*)?
	')'
;

OperationCallParameter:
	XExpression
;

Operation returns Variable:
	{Operation} name=ID '('
		(params+=ParameterVariable (',' params+=ParameterVariable)*)?
	')''{'
		block=OperationBlock
	'}' ('returns' (return=XExpression | returnvar=Variable) ';')?
;

OperationBlock:
	{OperationBlock} (steps+=OperationStep)*
;

ParameterVariable returns Variable:
	{ParameterVariable} (kind=ParameterKind)? type=TypeDef name=ID ('=' default=LITERAL)?  
;

enum ParameterKind:
	ANY='default' | VAR='var' | CONST='const'
;

/****************
 * OPERATORS
 ******************/

enum OperationRole:
	SET='SET' | ADD='ADD' | SUBTRACT='SUBTRACT' | AND='AND' | OR='OR' | XOR='XOR' |
	EQUALS='EQUALS' | BRANCH='BRANCH' | UC_GOTO='UC_GOTO' | NOT='NOT' | INDIRECTION='INDIRECTION' |
	CLEAR='CLEAR' | INCREMENT='INCREMENT' | DECREMENT='DECREMENT' | DIV='DIV' | MOD='MOD'
	| LT='LT' | LTE='LTE' | GT='GT' | GTE='GTE'
;

OperatorDefinition:
	'operator' role=OperationRole '{'
		candidate+=[Operation|ReferenceID] (',' candidate+=[Operation|ReferenceID])* (',')?
	'}'
;

/********************
 * BINARY and LINKING
 ********************/

LinkedBinary:
	'binary' name=QualifiedName (type=BinaryType)? ';'
	('use' use+=[Library|QualifiedName]';')*
		(sections+=BinarySection)*
;

enum BinaryType:
	DEFAULT='default' | HEXFILE='hexfile'
;

BinarySection:
	(FunctionBinarySection | ConstantBinarySection | ReferenceBinarySection) 'at' start=XExpression ';'
;
 
FunctionBinarySection:
	'program' name=ID '('
		'startAddr' '=' startAddr=LITERAL ';'
		'memwidth' '=' memwidth=LITERAL ';'
		'pointersize' '=' pointersize=LITERAL ';'
		'addressType' '=' addressType=TypeDef ';'
		(mems+=FunctionMemory ';')+
	')' '{'
		(
		('lib' lib+=[Library|QualifiedName] ';') |
		(instances+=LinkedInstance )
		)*
		
		'link' '{' do=OperationBlock '}'
	'}'
; 

LinkedInstance:
	type=[Module|QualifiedName] name=ID '{'
			( 
			(links+=ReferenceLink | confs+=InstanceConfig)	
			';')*
		'}'
;

ReferenceLink:
	ref=[InstanceReference|ID] ':' inst=[LinkedInstance|ID]
;

InstanceConfig:
	conf=[ConfigVariable|ID] '=' value=XExpression
;

FunctionMemory:
	'mem' start=LITERAL '..' end=LITERAL
;
 
ConstantBinarySection:
	'data' '{' (data+=XExpression ';')+ '}'
; 

ReferenceBinarySection:
	'include' inc=[LinkedBinary|QualifiedName]
;

/********************
 * INFIX SYNTAX
 **********************/
 
XExpression:
	XExpression6;

XPrimaryExpression:
	XExpressionLiteral | XParenthesizedExpression | XIsLiteralExpression | VariableReference | OperationCall
	 | XStructExpression | XSizeOfExpression
;

XSizeOfExpression:
	'sizeof' '(' type = TypeDef ')'
;

XStructExpression:
	type=[Type|ReferenceID] '{' values+=XExpression (',' values+=XExpression)* (',')? '}'
;

XExpression1:
	(operator += UNARY_OPERATOR)* a=XExpression0
;

XExpression0:
	a=XExpressionM1 ('->' member+=ID)*
;

XExpressionM1:
	a=XPrimaryExpression ('[' index+=XExpression ']')*
;

enum UNARY_OPERATOR:
	MINUS='-' | NOT='!' | REFERENCE='&' | DEREFERENCE='@'
;

XExpression2:
	a = XExpression1 (=> op+=MULTIPLICATIVE_OPERATOR b+= XExpression2)*
;

enum MULTIPLICATIVE_OPERATOR:
	MUL='*' | DIV='/' | MOD='%'
;

XExpression3:
	a = XExpression2 (=> op+=ADDITIVE_OPERATOR b+= XExpression2)*
;

enum ADDITIVE_OPERATOR:
	ADD='+' | 
	MINUS='-'
;

XExpression4:
	a = XExpression3 (=> op+=EQUALITY_OPERATOR b+=XExpression3)*
;

enum EQUALITY_OPERATOR:
	EQUALS='==' | NOTEQUALS='!=' | GTE='>=' | LTE='<=' | GT='>' | LT='<'
;

XExpression5:
	a = XExpression4 (=> op+=BOOLEAN_OPERATOR b+=XExpression4)*
;

XExpression6:
	(=> ref+=VariableReference OpSingleAssign)* a=XExpression5
;

enum BOOLEAN_OPERATOR:
	OR='||' | AND='&&' 
;

XExpressionLiteral:
	value=LITERAL
;

XTopLevelExpression:
	Annotation ';' | XExpression ';' | XIfExpression | XWhileExpression
;

OpSingleAssign:
	'='
;

XIsLiteralExpression:
	'isliteral' '('
		ref = VariableReference
	')'
;

XIfExpression:
	'if' '(' if=XExpression ')' '{'
	then=OperationBlock
	'}'
	(=> 'else' '{' else=OperationBlock '}')?;
	
XWhileExpression:
	'while' '(' cond=XExpression ')' '{'
		do=OperationBlock
	'}'
;	
	
XParenthesizedExpression:
	'(' a=XExpression ')';

	